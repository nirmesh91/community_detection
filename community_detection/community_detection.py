import networkx as nx

"""
Based on J. Baumes, M. Goldberg, and M. Magdon-ismail, “Efficient identification of overlapping communities,” in In IEEE International
Conference on Intelligence and Security Informatics
(ISI, pp. 27–36, 2005.)
"""

def main():
    # reading the input and creating a directed graph from it using newtworkx
    v,e = [int(x) for x in input().split(' ')] 

    #Using directed graphs of networkx as my primary data structure to store the entire graph
    G = nx.DiGraph()
    for i in range(e):
        n1,n2 = [int(x) for x in input().split(' ')]
        G.add_edge(n1,n2)


    #Call the LA funtion to create initial set of clusters.
    C = LA(G)

    final_communities = []

    #Improving each seed cluster generated by LA function.
    for seed in C:
        final_communities.append( IS2(seed, G) )

    #Removing the communities that are too small i.e contains less than 3 nodes.
    refined_comm = [sorted(x) for x in final_communities if len(x) > 3]

    #print("######## Final Communities #########")
    for comm in refined_comm:
        x = ''
        for node in comm:
            x = x + str(node) + ' '
        print(x)


def W(G, C):
    """Density metric W function. This is essentially the scoring function which we use to define our communitites.
    The formula used to calculate density :  W = 2 * e_c / c ; 
    where e_c is number of edges with both endpoints in cluster 'C' and c is total number of nodes in cluster"""
    e_c = 0
    c = len(C)

    community = G.subgraph(C)
    for e in community.edges():
        if (e[0] in C) and (e[1] in C):
            e_c = e_c + 1

    if c > 0:
        return (2*e_c/c)
    else:
        return 0


def LA(G):
    """This function defines the initial clusters. 
    Since the clusters are going to be refined by IS2 function, it only finds good approximate clusters. 
    A node is added to any cluster if adding it improves the cluster density. 
    If the node is not added to any cluster, it creates a new cluster"""
    C = []
    #Calculating the pagerank
    page_rank = nx.pagerank(G)

    #Sorting nodes in the order of page_rank
    sorted_node_list = sorted(page_rank, key=page_rank.get,reverse=True)

    for i in sorted_node_list:

        if len(C) == 0:
            #if length is zero, add the node to create first cluster
            C.append([i])
        else:
            added = False

            #For each cluster in C list, check by adding this particular node, 
            #whether the cluster is improving or not with scoring function "W"
            for D_j in C:

                union_list = D_j[:]

                #Add the node to the cluster
                union_list.append(i)
                
                #check if the weight function yields better result by adding the current node into the previous cluster
                if W(G,union_list) > W(G,D_j):
                    D_j.append(i)
                    added = True
            
            #Else create a new cluster with the current node
            if added == False:
                C.append([i])
    return C


def IS2(seed,G):
    """This function improves the existing clusters. 
    We improve by adding the neighbouring nodes of the cluster to it and checking if density is improving or not."""
    C = seed[:]
    w = W(G,C)
    increased = True

    while increased:
        N = C[:]

        #Extend each cluster to include its neighbours
        for v in C:
            N.extend(G.neighbors(v))

        for v in N:
            #if the v is already part of origional cluster, we check the density by removing the v from set. Else we make union and check density
            if v in C:
                C_dash = list( set(C) - set([v]) )
            else:
                C_dash = list( set(C).union(set([v])) )


            #If density improves, make this new cluster.
            if W(G,C_dash) > W(G,C):
                C = C_dash[:]

        w_g_c = W(G,C)
        
        #If no improvement, set increased = false and break out of the loop
        if w_g_c == w:
            increased = False
        else:
            w = w_g_c

    #return improved clusters.
    return C



if __name__ == "__main__":
    main()


    
    



